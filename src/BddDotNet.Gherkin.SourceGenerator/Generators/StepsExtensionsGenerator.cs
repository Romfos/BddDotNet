using BddDotNet.Gherkin.SourceGenerator.Models;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System.Collections.Immutable;
using System.Text;

namespace BddDotNet.Gherkin.SourceGenerator.Generators;

[Generator]
internal sealed class StepsExtensionsGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var givenStepDeclarationNodes = context.SyntaxProvider
            .ForAttributeWithMetadataName(
                "BddDotNet.Gherkin.GivenAttribute",
                static (node, _) => node is MethodDeclarationSyntax && node.Parent is ClassDeclarationSyntax,
                GetGherkinStep)
            .Collect();

        var whenStepDeclarationNodes = context.SyntaxProvider
            .ForAttributeWithMetadataName(
                "BddDotNet.Gherkin.WhenAttribute",
                static (node, _) => node is MethodDeclarationSyntax && node.Parent is ClassDeclarationSyntax,
                GetGherkinStep)
            .Collect();

        var thenStepDeclarationNodes = context.SyntaxProvider
            .ForAttributeWithMetadataName(
                "BddDotNet.Gherkin.ThenAttribute",
                static (node, _) => node is MethodDeclarationSyntax && node.Parent is ClassDeclarationSyntax,
                GetGherkinStep)
            .Collect();

        var arguments = givenStepDeclarationNodes
            .Combine(whenStepDeclarationNodes)
            .Combine(thenStepDeclarationNodes);

        context.RegisterImplementationSourceOutput(arguments, static (context, args) =>
        {
            var ((givenNodes, whenNodes), thenNodes) = args;

            var methodBodyContent = GetMethodBodyContent(givenNodes, whenNodes, thenNodes);
            var content = GenerateClassContent(methodBodyContent);
            var formattedContent = FormatCode(content);

            context.AddSource("SourceGeneratedGherkinSteps.cs", formattedContent);
        });
    }

    public static string FormatCode(string code)
    {
        return CSharpSyntaxTree.ParseText(code)
            .GetRoot()
            .NormalizeWhitespace()
            .SyntaxTree
            .GetText()
            .ToString();
    }

    private static string GenerateClassContent(string methodBodyContent)
    {
        var classContent =
            $$"""
            // <auto-generated/>
            
            #nullable disable warnings

            using BddDotNet;
            using Microsoft.Extensions.DependencyInjection;
            using Microsoft.Extensions.DependencyInjection.Extensions;

            namespace BddDotNet.Gherkin;

            internal static partial class GherkinSourceGeneratorExtensions
            {
                public static partial void SourceGeneratedGherkinSteps(this IServiceCollection services)
                {
                    {{methodBodyContent}}
                }
            }
            """;

        return classContent;
    }

    private static string GetMethodBodyContent(ImmutableArray<GherkinStep> givenSteps, ImmutableArray<GherkinStep> whenSteps, ImmutableArray<GherkinStep> thenSteps)
    {
        var methodBodyContent = new StringBuilder();

        methodBodyContent.AppendLine(GetServiceRegistrationsContent(givenSteps, whenSteps, thenSteps));
        methodBodyContent.AppendLine(GetStepRegistrations("Given", givenSteps));
        methodBodyContent.AppendLine(GetStepRegistrations("When", whenSteps));
        methodBodyContent.AppendLine(GetStepRegistrations("Then", thenSteps));

        return methodBodyContent.ToString();
    }

    private static string GetServiceRegistrationsContent(
        ImmutableArray<GherkinStep> givenSteps,
        ImmutableArray<GherkinStep> whenSteps,
        ImmutableArray<GherkinStep> thenSteps)
    {
        var typeRegistrations = new StringBuilder();

        var serviceTypeNames = givenSteps
            .Concat(whenSteps)
            .Concat(thenSteps)
            .Select(x => x.ServiceTypeName)
            .Distinct();

        foreach (var serviceTypeName in serviceTypeNames)
        {
            typeRegistrations.AppendLine(
                $$"""
                services.TryAddScoped<{{serviceTypeName}}>();
                """);
        }

        return typeRegistrations.ToString();
    }

    private static string GetStepRegistrations(string extensionMethodName, ImmutableArray<GherkinStep> steps)
    {
        var stepRegistrations = new StringBuilder();

        foreach (var step in steps)
        {
            stepRegistrations.AppendLine(
                $$"""
                services.{{extensionMethodName}}(
                    new("{{step.Pattern}}"),
                    services => services.GetRequiredService<{{step.ServiceTypeName}}>().{{step.MethodName}});
                """);
        }

        return stepRegistrations.ToString();
    }

    private static GherkinStep GetGherkinStep(GeneratorAttributeSyntaxContext context, CancellationToken cancellationToken)
    {
        var methodDeclaration = (MethodDeclarationSyntax)context.TargetNode;
        var classDeclaration = (ClassDeclarationSyntax)methodDeclaration.Parent!;

        var typeName = context.SemanticModel.GetDeclaredSymbol(classDeclaration)!.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
        var methodName = context.SemanticModel.GetDeclaredSymbol(methodDeclaration)!.Name;

        var pattern = context.Attributes
            .Select(attr => (string)attr.ConstructorArguments[0].Value!)
            .Single();

        return new(pattern, typeName, methodName);
    }
}
